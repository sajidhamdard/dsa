**Letter Case Permutation**

---

### **Understanding the Problem**
The problem requires generating all possible strings by toggling the case of each letter in the given string while keeping digits unchanged.

For example,  
**Input:** `"a1b2"`  
**Output:** `["a1b2", "A1b2", "a1B2", "A1B2"]`

---

## **Approach 1: Bitmasking (Iterative)**
```java
class Solution {
    public List<String> letterCasePermutation(String s) {
        return permutation(s.toLowerCase());
    }
    
    public List<String> permutation(String s) {
        Set<String> set = new HashSet<>();
        int n = s.length();
        int totalSubsets = 1 << n;  // 2^n subsets
        for (int i = 0; i < totalSubsets; i++) {
            StringBuilder sb = new StringBuilder(s);
            for (int j = 0; j < n; j++) {
                if ((i & (1 << j)) != 0) { // Check if bit is set
                    sb.setCharAt(j, Character.toUpperCase(s.charAt(j)));
                }
            }
            set.add(sb.toString());
        }
        return new ArrayList<>(set);
    }
}
```

### **Explanation**
- Converts the input string to lowercase.
- Uses bitmasking to generate all possible case combinations.
- Iterates through all `2^n` subsets where `n` is the string length.
- Uses a `Set<String>` to avoid duplicates.

### **Complexity Analysis**
- **Time Complexity:** **O(2^n * n)** (2^n subsets, each requiring O(n) to construct)
- **Space Complexity:** **O(2^n)** (stores all generated strings)

### **Pros and Cons**
✅ Simple iterative approach using bitwise operations.  
❌ Inefficient when the input contains digits since they also contribute to `n`, but they don’t change case.

---

## **Approach 2: Backtracking with Subset Generation**
```java
class Solution {
    public List<String> letterCasePermutation(String s) {
        Set<String> ans = new HashSet<>();
        ans.add(s.toLowerCase());
        permutation(0, new StringBuilder(s.toLowerCase()), new ArrayList<>(), ans);
        return new ArrayList<>(ans);
    }
    
    public void permutation(int i, StringBuilder s, List<Integer> list, Set<String> ans) {
        for(int j = i; j < s.length(); j++) {
            list.add(j);
            if(!Character.isDigit(s.charAt(j))) {
                StringBuilder str = new StringBuilder(s);
                for(Integer n : list) {
                    str.setCharAt(n, Character.toUpperCase(str.charAt(n)));
                }
                ans.add(str.toString());
            }
            permutation(j+1, s, list, ans);
            list.remove(list.size()-1);
        }
    }
}
```

### **Explanation**
- Uses backtracking to explore all subsets.
- The `list` stores indices where case changes occur.
- At each step, a new string is generated by toggling characters in `list`.

### **Complexity Analysis**
- **Time Complexity:** **O(2^n * n)** (each character can either be toggled or not)
- **Space Complexity:** **O(2^n)** (for storing results)

### **Pros and Cons**
✅ Uses backtracking, avoiding unnecessary iterations.  
❌ Uses an extra list (`list<Integer>`) to track toggled indices.  
❌ Generates duplicate strings, requiring a `Set<String>` to remove them.

---

## **Approach 3: Pure Backtracking (Most Efficient)**
```java
class Solution {
    public List<String> letterCasePermutation(String s) {
        List<String> ans = new ArrayList<>();
        permutation(0, new StringBuilder(s.toLowerCase()), ans);
        return ans;
    }
    
    public void permutation(int i, StringBuilder s, List<String> list) {
        if(i == s.length()) {
            list.add(s.toString());
            return;
        }
        permutation(i+1, s, list);  // Case where we don't change the letter
        
        if(Character.isLetter(s.charAt(i))) {
            s.setCharAt(i, Character.isUpperCase(s.charAt(i)) 
                            ? Character.toLowerCase(s.charAt(i)) 
                            : Character.toUpperCase(s.charAt(i))); // Toggle case
            
            permutation(i+1, s, list);  // Explore with toggled character
            
            // Backtrack to restore original state
            s.setCharAt(i, Character.isUpperCase(s.charAt(i)) 
                            ? Character.toLowerCase(s.charAt(i)) 
                            : Character.toUpperCase(s.charAt(i)));
        }
    }
}
```

### **Explanation**
- Uses backtracking with **two recursive calls**:
  1. Keep the character as it is.
  2. Toggle the case and recurse.
- Restores original state after toggling (backtracking).

### **Complexity Analysis**
- **Time Complexity:** **O(2^n)** (each letter has two choices)
- **Space Complexity:** **O(2^n)** (for storing results)

### **Pros and Cons**
✅ Most optimal and intuitive recursive approach.  
✅ No need for extra data structures like `Set` or `List<Integer>`.  
✅ No redundant computations.  
❌ Uses recursion, which might cause stack overflow for very large inputs.

---

## **Final Comparison Table**

| Approach | Type | Time Complexity | Space Complexity | Pros | Cons |
|----------|------|----------------|------------------|------|------|
| **Bitmasking (Iterative)** | Iterative | **O(2^n * n)** | **O(2^n)** | Uses bitwise operations efficiently | Works inefficiently with digits |
| **Backtracking with Subsets** | Recursive | **O(2^n * n)** | **O(2^n)** | Uses subset generation | Requires extra `List<Integer>` to track indices |
| **Pure Backtracking (Best Approach)** | Recursive | **O(2^n)** | **O(2^n)** | Most optimal, avoids extra structures | Uses recursion (risk of stack overflow) |

---

### **Best Choice**
The **pure backtracking approach (Approach 3)** is the best solution because:
- It is **optimal** in terms of both time and space.
- It avoids unnecessary data structures.
- It directly toggles characters without redundant calculations.
